package ballotsignature

import (
	"crypto/ecdsa"
	"fmt"
	"math/big"

	gecc "github.com/consensys/gnark-crypto/ecc"
	gecdsa "github.com/consensys/gnark-crypto/ecc/secp256k1/ecdsa"
	ethcrypto "github.com/ethereum/go-ethereum/crypto"
	"github.com/vocdoni/vocdoni-z-sandbox/crypto"
	"github.com/vocdoni/vocdoni-z-sandbox/crypto/ethereum"
	"github.com/vocdoni/vocdoni-z-sandbox/types"
)

// Signature is the signature generated by a voter to sign the ballot as
// a proof of the authorship of the vote.
type Signature struct {
	R types.HexBytes `json:"r"`
	S types.HexBytes `json:"s"`
}

// Valid method checks if the BallotSignature is valid. A signature is valid if
// both R and S values are not nil.
func (sig *Signature) Valid() bool {
	return sig.R != nil && sig.S != nil
}

// BigInt returns the R and S values as big integers.
func (sig *Signature) BigInt() (*big.Int, *big.Int) {
	r := new(big.Int).SetBytes(sig.R)
	s := new(big.Int).SetBytes(sig.S)
	return r, s
}

// Bin returns the bytes of the binary representation of the signature, which
// is build by appending the R and S values as byte slices.
func (sig *Signature) Bin() []byte {
	return append(sig.R, sig.S...)
}

// Verify checks if the signature is valid for the given input and public key.
// The public key should be an ecdsa public key compressed in bytes. The input
// should be a big integer that will be converted in a byte slice ensuring that
// the final value is in the expected scalar field (BLS12_377) and has the
// expected size.
func (sig *Signature) Verify(signedInput *big.Int, expectedPubKey []byte) bool {
	if !sig.Valid() {
		return false
	}
	ffInput := crypto.BigIntToFFwithPadding(signedInput, gecc.BLS12_377.ScalarField())
	return ethcrypto.VerifySignature(expectedPubKey, ethereum.Hash(ffInput), sig.Bin())
}

// SignEthereumMessage signs an Ethereum message (adding the corresponding prefix) using the given private key.
func SignEthereumMessage(msg []byte, privKey *ecdsa.PrivateKey) (*Signature, error) {
	ethSignature, err := ethcrypto.Sign(ethereum.Hash(msg), privKey)
	if err != nil {
		return nil, fmt.Errorf("could not sign message: %w", err)
	}
	var sig gecdsa.Signature
	if _, err := sig.SetBytes(ethSignature[:64]); err != nil {
		return nil, fmt.Errorf("could not set bytes: %w", err)
	}
	return &Signature{
		R: sig.R[:],
		S: sig.S[:],
	}, nil
}

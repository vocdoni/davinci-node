package csp

import (
	"fmt"

	ecc_twedwards "github.com/consensys/gnark-crypto/ecc/twistededwards"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/std/algebra/emulated/sw_bn254"
	"github.com/consensys/gnark/std/algebra/native/twistededwards"
	"github.com/consensys/gnark/std/hash/mimc"
	"github.com/consensys/gnark/std/math/emulated"
	"github.com/consensys/gnark/std/signature/eddsa"
	"github.com/vocdoni/davinci-node/census"
	"github.com/vocdoni/davinci-node/circuits"
	"github.com/vocdoni/davinci-node/types"
	emumimc7 "github.com/vocdoni/gnark-crypto-primitives/hash/emulated/bn254/mimc7"
	"github.com/vocdoni/gnark-crypto-primitives/hash/native/bn254/mimc7"
	"github.com/vocdoni/gnark-crypto-primitives/utils"
)

// CSPProof struct represents a proof generated by the CredentialServiceProviders
// to be used in the circuits. It includes the signature, public key, process
// ID and address as variables. The IsValid method checks if the signature is
// valid or not using the gnark API.
type CSPProof struct {
	Signature eddsa.Signature
	PublicKey eddsa.PublicKey
}

// IsValid checks if the signature is valid or not. It returns 1 as a frontend
// variable if the signature is valid, and 0 if it is not.
// It recomputes the message hash with the process ID and address and verifies
// the signature against the public key and the message hash.
func (proof *CSPProof) IsValidEmulated(
	api frontend.API,
	curveID ecc_twedwards.ID,
	censusRoot, processID, address, weight emulated.Element[sw_bn254.ScalarField],
) frontend.Variable {
	// check if the census root matches the expected one
	validPubKey, err := proof.isEmulatedPubKeyValid(api, censusRoot)
	if err != nil {
		circuits.FrontendError(api, "failed to verify census root", err)
		return 0
	}
	// recompute the message hash with the process ID and address
	msg := emulatedSignatureMessage(api, processID, address, weight)
	// inititialize the twistededwards curve
	curve, err := twistededwards.NewEdCurve(api, curveID)
	if err != nil {
		circuits.FrontendError(api, "failed to create twistededwards curve", err)
		return 0
	}
	// initialize the mimc hash function
	hashFn, err := mimc.New(api)
	if err != nil {
		circuits.FrontendError(api, "failed to create mimc hash function", err)
		return 0
	}
	// check if the signature is valid
	validSignature, err := eddsa.IsValid(curve, proof.Signature, msg, proof.PublicKey, hashFn)
	if err != nil {
		circuits.FrontendError(api, "failed to verify signature", err)
		return 0
	}
	return api.And(validPubKey, validSignature)
}

func (proof *CSPProof) IsValid(
	api frontend.API,
	censusRoot, processID, address, weight frontend.Variable,
) frontend.Variable {
	// check if the census root matches the expected one
	validPubKey, err := proof.isPubKeyValid(api, censusRoot)
	if err != nil {
		circuits.FrontendError(api, "failed to verify census root", err)
		return 0
	}
	// recompute the message hash with the process ID and address
	msg := signatureMessage(api, processID, address, weight)
	// inititialize the twistededwards curve
	curve, err := twistededwards.NewEdCurve(api, census.CSPCensusOriginCurveID())
	if err != nil {
		circuits.FrontendError(api, "failed to create twistededwards curve", err)
		return 0
	}
	// initialize the mimc hash function
	hashFn, err := mimc.New(api)
	if err != nil {
		circuits.FrontendError(api, "failed to create mimc hash function", err)
		return 0
	}
	// check if the signature is valid
	validSignature, err := eddsa.IsValid(curve, proof.Signature, msg, proof.PublicKey, hashFn)
	if err != nil {
		circuits.FrontendError(api, "failed to verify signature", err)
		return 0
	}
	return api.And(validPubKey, validSignature)
}

func (proof *CSPProof) isEmulatedPubKeyValid(
	api frontend.API,
	censusRoot emulated.Element[sw_bn254.ScalarField],
) (frontend.Variable, error) {
	emulatedPubKeyX, err := utils.UnpackVarToScalar[sw_bn254.ScalarField](api, proof.PublicKey.A.X)
	if err != nil {
		return 0, err
	}
	emulatedPubKeyY, err := utils.UnpackVarToScalar[sw_bn254.ScalarField](api, proof.PublicKey.A.Y)
	if err != nil {
		return 0, err
	}

	pubKeyHasher, err := emumimc7.New(api)
	if err != nil {
		return 0, err
	}
	pubKeyHasher.Write(*emulatedPubKeyX, *emulatedPubKeyY)
	if !pubKeyHasher.WriteSucceeded() {
		return 0, fmt.Errorf("error writing hash inputs")
	}
	return pubKeyHasher.SumIsEqual(censusRoot), nil
}

func (proof *CSPProof) isPubKeyValid(
	api frontend.API,
	censusRoot frontend.Variable,
) (frontend.Variable, error) {
	pubKeyHasher, err := mimc7.New(api)
	if err != nil {
		return 0, err
	}
	pubKeyHasher.Write(proof.PublicKey.A.X, proof.PublicKey.A.Y)
	if !pubKeyHasher.WriteSucceeded() {
		return 0, fmt.Errorf("error writing hash inputs")
	}
	return pubKeyHasher.SumIsEqual(censusRoot), nil
}

// emulatedSignatureMessage computes the message hash for the signature. It
// expects the process ID and address as emulated elements of the BN254 curve.
// It uses the MiMC7 hash function to compute the hash of the process ID and
// address and then packs the result into a frontend variable of the circuit
// curve.
func emulatedSignatureMessage(api frontend.API, processID, address, weight emulated.Element[sw_bn254.ScalarField]) frontend.Variable {
	msgHasher, err := emumimc7.New(api)
	if err != nil {
		circuits.FrontendError(api, "failed to create mimc7 hash function for message", err)
		return 0
	}
	msgHasher.Write(processID, address, weight)
	if !msgHasher.WriteSucceeded() {
		circuits.FrontendError(api, "failed to write process ID and address to message hasher", nil)
		return 0
	}
	msg, err := utils.PackScalarToVar(api, msgHasher.Sum())
	if err != nil {
		circuits.FrontendError(api, "failed to pack message hash to variable", err)
		return 0
	}
	return msg
}

func signatureMessage(api frontend.API, processID, address, weight frontend.Variable) frontend.Variable {
	msgHasher, err := mimc7.New(api)
	if err != nil {
		circuits.FrontendError(api, "failed to create mimc7 hash function for message", err)
		return 0
	}
	msgHasher.Write(processID, address, weight)
	if !msgHasher.WriteSucceeded() {
		circuits.FrontendError(api, "failed to write process ID and address to message hasher", nil)
		return 0
	}
	return msgHasher.Sum()
}

// CensusProofToCSPProof converts a types.CensusProof to a CSPProof to be
// used in Gnark circuits. It unmarshals the public key and signature from
// the CensusProof and converts them to gnark circuit types.
func CensusProofToCSPProof(curveID ecc_twedwards.ID, censusProof *types.CensusProof) (*CSPProof, error) {
	// Unmarshal public key and convert to gnark circuit eddsa public key
	pubKey := new(eddsa.PublicKey)
	pubKey.Assign(curveID, censusProof.PublicKey)
	// Unmarshal signature and convert to gnark circuit eddsa signature
	signature := new(eddsa.Signature)
	signature.Assign(curveID, censusProof.Signature)
	return &CSPProof{
		Signature: *signature,
		PublicKey: *pubKey,
	}, nil
}

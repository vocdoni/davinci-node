package csp

import (
	"fmt"

	ecc_twedwards "github.com/consensys/gnark-crypto/ecc/twistededwards"
	"github.com/consensys/gnark/frontend"

	"github.com/iden3/go-iden3-crypto/babyjub"
	"github.com/vocdoni/davinci-node/circuits"
	cspeddsa "github.com/vocdoni/davinci-node/crypto/csp/eddsa"
	"github.com/vocdoni/davinci-node/types"
	"github.com/vocdoni/gnark-crypto-primitives/ecc/bn254/eddsa"
	"github.com/vocdoni/gnark-crypto-primitives/hash"
	"github.com/vocdoni/gnark-crypto-primitives/hash/native"
)

// CSPProof struct represents a proof generated by the CredentialServiceProviders
// to be used in the circuits. It includes the signature, public key, process
// ID and address as variables. The IsValid method checks if the signature is
// valid or not using the gnark API.
type CSPProof struct {
	Signature eddsa.Signature
	PublicKey eddsa.PublicKey
}

// IsValid method checks if the signature is valid or not using the gnark API.
// It initializes the poseidon hash function, checks if the public key is valid,
// recomputes the message hash with the process ID and address, and finally
// checks if the signature is valid using the eddsa verifier with poseidon hash.
func (proof *CSPProof) IsValid(
	api frontend.API,
	censusRoot, processID, address, weight frontend.Variable,
) frontend.Variable {
	// Initialize the poseidon hash function
	hashFn, err := native.Poseidon(api)
	if err != nil {
		circuits.FrontendError(api, "failed to create poseidon hash function", err)
		return 0
	}
	// Check if the census root matches the expected one
	validPubKey, err := proof.isPubKeyValid(hashFn, censusRoot)
	if err != nil {
		circuits.FrontendError(api, "failed to verify census root", err)
		return 0
	}
	// Recompute the message hash with the process ID and address
	msg, err := signatureMessage(hashFn, processID, address, weight)
	if err != nil {
		circuits.FrontendError(api, "failed to compose signature message", err)
		return 0
	}
	// Initialize the eddsa verifier
	verifier, err := eddsa.NewVerifier(api, hashFn)
	if err != nil {
		circuits.FrontendError(api, "failed to create eddsa verifier", err)
		return 0
	}
	// Check if the signature is valid
	validSignature := verifier.IsValid(proof.PublicKey, proof.Signature, msg)
	return api.And(validPubKey, validSignature)
}

// isPubKeyValid checks if the public key is valid using the provided hash
// function and the provided census root. It recomputes the census root by
// hashing the public key point coordinates and compares it with the provided
// census root. It returns the result of the comparison.
func (proof *CSPProof) isPubKeyValid(
	hashFn hash.Hash[frontend.Variable],
	censusRoot frontend.Variable,
) (frontend.Variable, error) {
	// Write the public key
	hashFn.Write(proof.PublicKey.A.X, proof.PublicKey.A.Y)
	if !hashFn.WriteSucceeded() {
		return 0, fmt.Errorf("error writing hash inputs")
	}
	// Get the result
	isValid := hashFn.SumIsEqual(censusRoot)
	// Reset the hash
	hashFn.Reset()
	// Return the result
	return isValid, nil
}

// signatureMessage composes the message to be signed by the CSP. The message
// is the hash of the concatenation of the process ID, the address and the
// weight, using the hash function provided.
func signatureMessage(
	hashFn hash.Hash[frontend.Variable],
	processID, address, weight frontend.Variable,
) (frontend.Variable, error) {
	hashFn.Write(processID, address, weight)
	if !hashFn.WriteSucceeded() {
		return 0, fmt.Errorf("error writing hash inputs")
	}
	return hashFn.Sum(), nil
}

// CensusProofToCSPProof converts a types.CensusProof to a CSPProof to be
// used in Gnark circuits. It unmarshals the public key and signature from
// the CensusProof and converts them to gnark circuit types.
func CensusProofToCSPProof(curveID ecc_twedwards.ID, censusProof *types.CensusProof) (*CSPProof, error) {
	// Unmarshal public key and convert to gnark circuit eddsa public key
	pubKey, err := cspeddsa.PublicKeyFromBytes(censusProof.PublicKey)
	if err != nil {
		return nil, fmt.Errorf("error unmarshaling public key: %w", err)
	}
	decSignature, err := cspeddsa.HexBytesToDecimalStringBytes(censusProof.Signature)
	if err != nil {
		return nil, fmt.Errorf("error decoding signature: %w", err)
	}
	// Unmarshal signature and convert to gnark circuit eddsa signature
	signature, err := babyjub.DecompressSig(decSignature)
	if err != nil {
		return nil, fmt.Errorf("error decompressing signature: %w", err)
	}
	return &CSPProof{
		Signature: eddsa.SignatureFromIden3(signature),
		PublicKey: eddsa.PublicKeyFromIden3(*pubKey),
	}, nil
}

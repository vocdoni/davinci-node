package csp

import (
	ecc_twedwards "github.com/consensys/gnark-crypto/ecc/twistededwards"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/std/algebra/emulated/sw_bn254"
	"github.com/consensys/gnark/std/algebra/native/twistededwards"
	"github.com/consensys/gnark/std/hash/mimc"
	"github.com/consensys/gnark/std/math/emulated"
	"github.com/consensys/gnark/std/signature/eddsa"
	"github.com/vocdoni/davinci-node/circuits"
	"github.com/vocdoni/davinci-node/types"
	"github.com/vocdoni/gnark-crypto-primitives/emulated/bn254/twistededwards/mimc7"
	"github.com/vocdoni/gnark-crypto-primitives/utils"
)

const curve = ecc_twedwards.BLS12_377

// CSPProof struct represents a proof generated by the CensusServiceProvider
// to be used in the circuits. It includes the signature, public key, process
// ID and address as variables. The IsValid method checks if the signature is
// valid or not using the gnark API.
type CSPProof struct {
	Signature eddsa.Signature
	PublicKey eddsa.PublicKey
}

// SerializedPubKey returns the public key as a slice of frontend variables.
func (proof *CSPProof) SerializedPubKey() []frontend.Variable {
	return []frontend.Variable{
		proof.PublicKey.A.X,
		proof.PublicKey.A.Y,
	}
}

// IsValid checks if the signature is valid or not. It returns 1 as a frontend
// variable if the signature is valid, and 0 if it is not.
// It recomputes the message hash with the process ID and address and verifies
// the signature against the public key and the message hash.
func (proof *CSPProof) IsValid(
	api frontend.API,
	censusRoot frontend.Variable,
	processID, address emulated.Element[sw_bn254.ScalarField],
) frontend.Variable {
	// initialize the mimc hash function
	hashFn, err := mimc.NewMiMC(api)
	if err != nil {
		circuits.FrontendError(api, "failed to create mimc hash function", err)
		return 0
	}
	// recompute the census root with the public key
	hashFn.Write(proof.SerializedPubKey()...)
	calculatedCensusRoot := hashFn.Sum()
	// check if the census root matches the expected one
	validPubKey := api.IsZero(api.Sub(censusRoot, calculatedCensusRoot))
	hashFn.Reset()
	// recompute the message hash with the process ID and address
	msg := emulatedSignatureMessage(api, processID, address)
	// inititialize the twistededwards curve
	curve, err := twistededwards.NewEdCurve(api, curve)
	if err != nil {
		circuits.FrontendError(api, "failed to create twistededwards curve", err)
		return 0
	}
	// check if the signature is valid
	hashFn.Reset()
	validSignature, err := eddsa.IsValid(curve, proof.Signature, msg, proof.PublicKey, &hashFn)
	if err != nil {
		circuits.FrontendError(api, "failed to verify signature", err)
		return 0
	}
	return api.And(validPubKey, validSignature)
}

// emulatedSignatureMessage computes the message hash for the signature. It
// expects the process ID and address as emulated elements of the BN254 curve.
// It uses the MiMC7 hash function to compute the hash of the process ID and
// address and then packs the result into a frontend variable of the circuit
// curve.
func emulatedSignatureMessage(api frontend.API, processID, address emulated.Element[sw_bn254.ScalarField]) frontend.Variable {
	msgHasher, err := mimc7.NewMiMC(api)
	if err != nil {
		circuits.FrontendError(api, "failed to create mimc7 hash function for message", err)
		return 0
	}
	if err := msgHasher.Write(processID, address); err != nil {
		circuits.FrontendError(api, "failed to write process ID and address to message hasher", err)
		return 0
	}
	msg, err := utils.PackScalarToVar(api, msgHasher.Sum())
	if err != nil {
		circuits.FrontendError(api, "failed to pack message hash to variable", err)
		return 0
	}
	return msg
}

// CensusProofToCSPProof converts a types.CensusProof to a CSPProof to be
// used in Gnark circuits. It unmarshals the public key and signature from
// the CensusProof and converts them to gnark circuit types.
func CensusProofToCSPProof(censusProof *types.CensusProof) (*CSPProof, error) {
	// Unmarshal public key and convert to gnark circuit eddsa public key
	pubKey := new(eddsa.PublicKey)
	pubKey.Assign(curve, censusProof.PublicKey)
	// Unmarshal signature and convert to gnark circuit eddsa signature
	signature := new(eddsa.Signature)
	signature.Assign(curve, censusProof.Signature)
	return &CSPProof{
		Signature: *signature,
		PublicKey: *pubKey,
	}, nil
}

// go run scripts/gen_omega_table.go > crypto/blobs/omega_limbs_table.go
package main

import (
	"fmt"
	"math/big"

	"github.com/consensys/gnark-crypto/ecc/bls12-381/fr"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/std/math/emulated"
)

const (
	n    = 4096
	logN = 12
)

func main() {
	mod := fr.Modulus()

	// go-eth-kzg root of unity (largest 2-adic subgroup generator)
	var rootOfUnity fr.Element
	if _, err := rootOfUnity.SetString("10238227357739495823651030575849232062558860180284477541189508159991286009131"); err != nil {
		panic(err)
	}
	element.New()
	// generator = rootOfUnity^(2^20)
	expo := new(big.Int).SetInt64(1 << 20)
	var generator fr.Element
	generator.Exp(rootOfUnity, expo)

	// natural order
	domainRoots := make([]fr.Element, n)
	domainRoots[0].SetOne()
	for i := 1; i < n; i++ {
		domainRoots[i].Mul(&domainRoots[i-1], &generator)
	}

	// get limbs of ω^i (bit-reversed order)
	limbs := make([][]frontend.Variable, n)
	for i := 0; i < n; i++ {
		idx := bitReverse(i, logN)
		bi := domainRoots[idx].BigInt(new(big.Int))
		limbs[i] = toLimbs(bi, mod) // <- fills Limbs via Initialize
	}

	// 4096^{-1} mod r
	nInv := new(big.Int).ModInverse(big.NewInt(n), mod)
	nInvLimbs := toLimbs(nInv, mod)

	// --------------------------------------------------------------
	// Emit code
	// --------------------------------------------------------------
	fmt.Println("// Code generated by gen_omega_table.go; DO NOT EDIT.")
	fmt.Println("// Generated using go-eth-kzg compatible omega values with bit-reversal.")
	fmt.Println()
	fmt.Println("package blobs")
	fmt.Println()
	fmt.Println("import (")
	fmt.Println("\t\"github.com/consensys/gnark/frontend\"")
	fmt.Println("\t\"github.com/consensys/gnark/std/math/emulated\"")
	fmt.Println(")")
	fmt.Println()
	fmt.Println("// omegaLimbs[i] holds the limbs of ω^i (bit-reversed) in BLS12-381 Fr (emulated).")
	fmt.Println("var omegaLimbs = [4096][]frontend.Variable{")
	for i := 0; i < n; i++ {
		fmt.Print("\t{")
		for j, limb := range limbs[i] {
			fmt.Printf("\"0x%s\"", limbToHex(limb))
			if j != len(limbs[i])-1 {
				fmt.Print(", ")
			}
		}
		fmt.Println("},")
	}
	fmt.Println("}")
	fmt.Println()
	fmt.Println("// nInverseLimbs are the limbs of 4096^{-1} mod r.")
	fmt.Println("var nInverseLimbs = []frontend.Variable{")
	for _, limb := range nInvLimbs {
		fmt.Printf("\t\"0x%s\",", limbToHex(limb))
		fmt.Println()
	}
	fmt.Println("}")
	fmt.Println()
	fmt.Println("// omegaAt rebuilds an emulated element from limbs inside the circuit.")
	fmt.Println("func omegaAt(i int) emulated.Element[emulated.BLS12381Fr] {")
	fmt.Println("\treturn emulated.Element[emulated.BLS12381Fr]{Limbs: omegaLimbs[i]}")
	fmt.Println("}")
	fmt.Println()
	fmt.Println("var nInverse = emulated.Element[emulated.BLS12381Fr]{Limbs: nInverseLimbs}")
}

func bitReverse(x, logN int) int {
	var r int
	for i := 0; i < logN; i++ {
		if x&(1<<i) != 0 {
			r |= 1 << (logN - 1 - i)
		}
	}
	return r
}

// toLimbs: make ValueOf -> Initialize to actually fill Limbs.
func toLimbs(bi *big.Int, modulus *big.Int) []frontend.Variable {
	el := emulated.ValueOf[emulated.BLS12381Fr](bi)
	p := &el
	p.Initialize(modulus) // <- crucial
	return p.Limbs
}

func limbToHex(v frontend.Variable) string {
	switch t := v.(type) {
	case *big.Int:
		return t.Text(16)
	case string:
		if len(t) >= 2 && (t[:2] == "0x" || t[:2] == "0X") {
			return t[2:]
		}
		return t
	default:
		return fmt.Sprintf("%x", t)
	}
}

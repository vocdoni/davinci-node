// Command gen_omega_table produces a Go source file containing:
//
//	var omega     = [4096]emulated.Element[…]
//	var nInverse  = emulated.Element[…]
//
// where omega[i] = ωⁱ (natural order, *not* bit‑reversed) and
// nInverse = 4096⁻¹ mod p  for the BLS12‑381 scalar field.
package main

import (
	"fmt"
	"math/big"

	bls12381 "github.com/consensys/gnark-crypto/ecc/bls12-381"
)

func main() {
	const n = 4096

	mod := bls12381.ID.ScalarField()

	// ω = 5^{(p‑1)/4096}
	exp := new(big.Int).Sub(mod, big.NewInt(1))
	exp.Div(exp, big.NewInt(n))

	omega1 := new(big.Int).Exp(big.NewInt(5), exp, mod)

	roots := make([]*big.Int, n)
	roots[0] = big.NewInt(1)
	for i := 1; i < n; i++ {
		roots[i] = new(big.Int).Mul(roots[i-1], omega1)
		roots[i].Mod(roots[i], mod)
	}

	nInv := new(big.Int).ModInverse(big.NewInt(n), mod)

	//--------------------------------------------------------------------
	// Emit Go source
	//--------------------------------------------------------------------
	fmt.Println("// Code generated by gen_omega_table.go; DO NOT EDIT.")
	fmt.Println()
	fmt.Println("package blobs")
	fmt.Println()
	fmt.Println("import (")
	fmt.Println("\t\"github.com/consensys/gnark/std/algebra/emulated/sw_bls12381\"")
	fmt.Println("\t\"github.com/consensys/gnark/std/math/emulated\"")
	fmt.Println(")")
	fmt.Println()
	fmt.Println("// omega[i] = ω^i  (natural order) for the BLS12‑381 scalar field.")
	fmt.Println("var omega = [4096]emulated.Element[sw_bls12381.ScalarField]{")
	for i := 0; i < n; i++ {
		fmt.Printf("\temulated.ValueOf[sw_bls12381.ScalarField](\"0x%s\"),\n", roots[i].Text(16))
	}
	fmt.Println("}")
	fmt.Println()
	fmt.Printf("// nInverse = 4096⁻¹ mod p\n")
	fmt.Printf("var nInverse = emulated.ValueOf[sw_bls12381.ScalarField](\"0x%s\")\n", nInv.Text(16))
}

package main

import (
	"fmt"
	"math/big"
	"math/bits"

	bls12381 "github.com/consensys/gnark-crypto/ecc/bls12-381"
)

func bitReverse12(x uint32) uint32 {
	return bits.Reverse32(x) >> 20 // keep the low-12 reversed bits
}

func main() {
	// BLS12-381 scalar field modulus
	mod := bls12381.ID.ScalarField()

	// Compute the 4096-th root of unity using generator 5
	pMinus1 := new(big.Int).Sub(mod, big.NewInt(1))
	generator := big.NewInt(5)
	exponent := new(big.Int).Div(pMinus1, big.NewInt(4096))
	root4096 := new(big.Int).Exp(generator, exponent, mod)

	// Verify it's a 4096-th root of unity
	test := new(big.Int).Exp(root4096, big.NewInt(4096), mod)
	if test.Cmp(big.NewInt(1)) != 0 {
		panic(fmt.Sprintf("root4096^4096 = %s, expected 1", test.String()))
	}

	// Verify it's primitive (not a lower order root)
	test2 := new(big.Int).Exp(root4096, big.NewInt(2048), mod)
	if test2.Cmp(big.NewInt(1)) == 0 {
		panic("root is not primitive, it's a 2048-th root")
	}

	// Generate all 4096 roots in natural order
	omegaNatural := make([]*big.Int, 4096)
	omegaNatural[0] = big.NewInt(1)
	for i := 1; i < 4096; i++ {
		omegaNatural[i] = new(big.Int).Mul(omegaNatural[i-1], root4096)
		omegaNatural[i].Mod(omegaNatural[i], mod)
	}

	// Apply bit-reversal permutation to match c-kzg-4844's brp_roots_of_unity
	omega := make([]*big.Int, 4096)
	for i := 0; i < 4096; i++ {
		brpIdx := bitReverse12(uint32(i)) // log2(4096) = 12
		omega[i] = omegaNatural[brpIdx]
	}

	// Calculate nInverse = 4096^(-1) mod p
	nInverse := new(big.Int).ModInverse(big.NewInt(4096), mod)

	// Generate Go code
	fmt.Println("// Code generated by scripts/gen_omega_table.go; DO NOT EDIT.")
	fmt.Println()
	fmt.Println("package blobs")
	fmt.Println()
	fmt.Println("import (")
	fmt.Println("\t\"github.com/consensys/gnark/std/algebra/emulated/sw_bls12381\"")
	fmt.Println("\t\"github.com/consensys/gnark/std/math/emulated\"")
	fmt.Println(")")
	fmt.Println()

	// Output omega array
	fmt.Println("// omega contains the 4096 roots of unity for BLS12-381 scalar field")
	fmt.Println("// in bit-reversed order to match c-kzg-4844's brp_roots_of_unity")
	fmt.Println("var omega = [4096]emulated.Element[sw_bls12381.ScalarField]{")
	for i := 0; i < 4096; i++ {
		hexValue := fmt.Sprintf("0x%s", omega[i].Text(16))
		if i < 4095 {
			fmt.Printf("\temulated.ValueOf[sw_bls12381.ScalarField](\"%s\"),\n", hexValue)
		} else {
			fmt.Printf("\temulated.ValueOf[sw_bls12381.ScalarField](\"%s\"),\n", hexValue)
		}
	}
	fmt.Println("}")
	fmt.Println()

	// Output nInverse
	fmt.Printf("// nInverse is 4096^(-1) mod BLS12-381 scalar field modulus\n")
	fmt.Printf("var nInverse = emulated.ValueOf[sw_bls12381.ScalarField](\"0x%s\")\n", nInverse.Text(16))
}

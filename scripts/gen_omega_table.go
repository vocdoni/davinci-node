// Command gen_omega_table produces a Go source file containing:
//
//	var omega     = [4096]emulated.Element[…]
//	var nInverse  = emulated.Element[…]
//
// where omega[i] matches go-eth-kzg's domain values exactly (with bit-reversal applied)
// and nInverse = 4096⁻¹ mod p for the BLS12‑381 scalar field.
package main

import (
	"fmt"
	"math/big"

	fr "github.com/consensys/gnark-crypto/ecc/bls12-381/fr"
)

func main() {
	const n = 4096

	mod := fr.Modulus()

	// Use go-eth-kzg's exact approach:
	// Root of unity from go-eth-kzg (generator of largest 2-adic subgroup)
	var rootOfUnity fr.Element
	_, err := rootOfUnity.SetString("10238227357739495823651030575849232062558860180284477541189508159991286009131")
	if err != nil {
		panic(fmt.Sprintf("failed to initialize root of unity: %v", err))
	}

	// Calculate generator for domain size 4096: rootOfUnity^(2^20)
	expo := new(big.Int).SetInt64(1 << 20)
	var generator fr.Element
	generator.Exp(rootOfUnity, expo)

	// Generate domain roots in natural order
	domainRoots := make([]fr.Element, n)
	domainRoots[0].SetOne()
	for i := 1; i < n; i++ {
		domainRoots[i].Mul(&domainRoots[i-1], &generator)
	}

	// Apply bit-reversal permutation to match go-eth-kzg's domain ordering
	omega := make([]*big.Int, n)
	for i := 0; i < n; i++ {
		bitRevIndex := bitReverse(i, 12)
		omega[i] = domainRoots[bitRevIndex].BigInt(new(big.Int))
	}

	nInv := new(big.Int).ModInverse(big.NewInt(n), mod)

	// Verification: Print first few values for comparison
	fmt.Printf("// First 5 omega values (for verification):\n")
	for i := 0; i < 5; i++ {
		fmt.Printf("//   ω[%d] = 0x%s\n", i, omega[i].Text(16))
	}
	fmt.Printf("//\n")

	//--------------------------------------------------------------------
	// Emit Go source
	//--------------------------------------------------------------------
	fmt.Println("// Code generated by gen_omega_table.go; DO NOT EDIT.")
	fmt.Println("// Generated using go-eth-kzg compatible omega values with bit-reversal")
	fmt.Println()
	fmt.Println("package blobs")
	fmt.Println()
	fmt.Println("import (")
	fmt.Println("\t\"github.com/consensys/gnark/std/algebra/emulated/sw_bls12381\"")
	fmt.Println("\t\"github.com/consensys/gnark/std/math/emulated\"")
	fmt.Println(")")
	fmt.Println()
	fmt.Println("// omega[i] = ω^i with bit-reversal applied to match go-eth-kzg domain")
	fmt.Println("var omega = [4096]emulated.Element[sw_bls12381.ScalarField]{")
	for i := 0; i < n; i++ {
		fmt.Printf("\temulated.ValueOf[sw_bls12381.ScalarField](\"0x%s\"),\n", omega[i].Text(16))
	}
	fmt.Println("}")
	fmt.Println()
	fmt.Printf("// nInverse = 4096⁻¹ mod p\n")
	fmt.Printf("var nInverse = emulated.ValueOf[sw_bls12381.ScalarField](\"0x%s\")\n", nInv.Text(16))
}

// bitReverse reverses the bits of x, considering only the low logN bits.
func bitReverse(x, logN int) int {
	result := 0
	for i := 0; i < logN; i++ {
		if x&(1<<i) != 0 {
			result |= 1 << (logN - 1 - i)
		}
	}
	return result
}

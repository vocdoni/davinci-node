package ballotprooftest

import (
	"crypto/rand"
	_ "embed"
	"encoding/json"
	"fmt"
	"log"
	"math/big"
	"time"

	"github.com/iden3/go-iden3-crypto/babyjub"
	"github.com/iden3/go-rapidsnark/prover"
	"github.com/iden3/go-rapidsnark/witness"
	"github.com/vocdoni/davinci-node/circuits"
	"github.com/vocdoni/davinci-node/circuits/ballotproof"
	"github.com/vocdoni/davinci-node/crypto/ecc"
	bjj "github.com/vocdoni/davinci-node/crypto/ecc/bjj_gnark"
	"github.com/vocdoni/davinci-node/crypto/ecc/format"
	"github.com/vocdoni/davinci-node/crypto/elgamal"
	"github.com/vocdoni/davinci-node/crypto/signatures/ethereum"
	"github.com/vocdoni/davinci-node/types"
)

//go:embed circom_assets/ballot_proof.wasm
var TestCircomCircuit []byte

//go:embed circom_assets/ballot_proof_pkey.zkey
var TestCircomProvingKey []byte

//go:embed circom_assets/ballot_proof_vkey.json
var TestCircomVerificationKey []byte

// GenECDSAaccountForTest generates a new ECDSA account and returns the private
// key, public key and address.
func GenECDSAaccountForTest() (*ethereum.Signer, error) {
	// generate ecdsa keys and address (privKey and publicKey)
	privKey, err := ethereum.NewSigner()
	if err != nil {
		return nil, err
	}
	return privKey, nil
}

// SignECDSAForTest signs the data with the private key provided and returns the R and
// S values of the signature.
func SignECDSAForTest(privKey *ethereum.Signer, data []byte) (*ethereum.ECDSASignature, error) {
	return privKey.Sign(data)
}

// GenEncryptionKeyForTest generates a new encryption key for testing
// purposes. It uses the Iden3 implementation of the BabyJubJub curve to
// simplify the process.
func GenEncryptionKeyForTest() ecc.Point {
	privkey := babyjub.NewRandPrivKey()

	x, y := format.FromTEtoRTE(privkey.Public().X, privkey.Public().Y)
	return new(bjj.BJJ).SetPoint(x, y)
}

// GenBallotFieldsForTest generates a list of n random fields between min and max
// values. If unique is true, the fields will be unique.
// The items between n and NFields are padded with big.Int(0)
func GenBallotFieldsForTest(n, max, min int, unique bool) [types.FieldsPerBallot]*types.BigInt {
	fields := [types.FieldsPerBallot]*types.BigInt{}
	for i := range len(fields) {
		fields[i] = types.NewInt(0)
	}
	stored := map[string]bool{}
	for i := range n {
		for {
			// generate random field
			field, err := rand.Int(rand.Reader, big.NewInt(int64(max-min)))
			if err != nil {
				panic(err)
			}
			field.Add(field, big.NewInt(int64(min)))
			// if it should be unique and it's already stored, skip it,
			// otherwise add it to the list of fields and continue
			if !unique || !stored[field.String()] {
				fields[i] = fields[i].SetBigInt(field)
				stored[field.String()] = true
				break
			}
		}
	}
	return fields
}

// CompileAndGenerateProofForTest compiles a circom circuit, generates the witness and
// generates the proof using the inputs provided. It returns the proof and the
// public signals of the proof. It uses Rapidsnark and Groth16 prover to
// generate the proof.
func CompileAndGenerateProofForTest(inputs []byte) (string, string, error) {
	finalInputs, err := witness.ParseInputs(inputs)
	if err != nil {
		return "", "", fmt.Errorf("circom inputs: %w", err)
	}
	// instance witness calculator
	calc, err := witness.NewCircom2WitnessCalculator(TestCircomCircuit, true)
	if err != nil {
		return "", "", fmt.Errorf("instance witness calculator: %w", err)
	}
	// calculate witness
	w, err := calc.CalculateWTNSBin(finalInputs, true)
	if err != nil {
		return "", "", fmt.Errorf("calculate witness: %w", err)
	}
	// generate proof
	return prover.Groth16ProverRaw(TestCircomProvingKey, w)
}

// VoterProofResult struct includes all the public information generated by the
// user after ballot proof generation. It includes the value of the given
// process id and address in the format used inside the circuit.
type VoterProofResult struct {
	ProcessID  *big.Int
	Address    *big.Int
	Ballot     *elgamal.Ballot
	Proof      string
	PubInputs  string
	InputsHash *big.Int
	VoteID     types.HexBytes
}

// BallotProofForTest function return the information after proving a valid
// ballot for the voter address, process id and encryption key provided. It
// generates and encrypts the fields for the ballot and generates a proof of
// a valid vote. It returns a *VoterProofResult and an error if it fails.
func BallotProofForTest(address []byte, processID *types.ProcessID, encryptionKey ecc.Point) (*VoterProofResult, error) {
	now := time.Now()
	// generate random fields
	fields := GenBallotFieldsForTest(circuits.MockMaxCount, circuits.MockMaxValue, circuits.MockMinValue, circuits.MockForceUniqueness > 0)
	// generate voter k
	k, err := elgamal.RandK()
	if err != nil {
		return nil, err
	}
	// generate ballot proof inputs
	ballotProofInputs := &ballotproof.BallotProofInputs{
		ProcessID:     processID.Marshal(),
		Address:       address,
		EncryptionKey: types.SliceOf(encryptionKey.BigInts(), types.BigIntConverter),
		K:             new(types.BigInt).SetBigInt(k),
		BallotMode:    circuits.MockBallotModeInternal(),
		Weight:        new(types.BigInt).SetInt(circuits.MockWeight),
		FieldValues:   fields[:],
	}
	proofInputs, err := ballotproof.GenerateBallotProofInputs(ballotProofInputs)
	if err != nil {
		return nil, fmt.Errorf("generate ballot proof inputs: %w", err)
	}
	// generate ballot proof
	bCircomInputs, err := json.Marshal(proofInputs.CircomInputs)
	if err != nil {
		return nil, err
	}
	circomProof, circomPubInputs, err := CompileAndGenerateProofForTest(bCircomInputs)
	if err != nil {
		return nil, fmt.Errorf("create circom proof: %w", err)
	}
	log.Printf("ballot proof generation ends, it tooks %s", time.Since(now))
	return &VoterProofResult{
		ProcessID:  proofInputs.CircomInputs.ProcessID.MathBigInt(),
		Address:    proofInputs.CircomInputs.Address.MathBigInt(),
		Ballot:     proofInputs.Ballot,
		Proof:      circomProof,
		PubInputs:  circomPubInputs,
		InputsHash: proofInputs.BallotInputsHash.MathBigInt(),
		VoteID:     proofInputs.VoteID,
	}, nil
}

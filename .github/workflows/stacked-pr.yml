name: Stacked PR Check

on:
  pull_request:
    types: [opened, reopened, synchronize, edited, ready_for_review]

permissions:
  contents: read
  pull-requests: write

jobs:
  stacked-pr:
    if: ${{ !github.event.pull_request.draft && github.event.pull_request.head.repo.full_name == github.event.pull_request.base.repo.full_name }}
    runs-on: ubuntu-latest
    steps:
      - name: Check stacked PR
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request.number;
            const baseRef = context.payload.pull_request.base.ref;
            const isMain = baseRef === "main";

            const isStackedBody = (body) =>
              typeof body === "string" &&
              /^This PR is stacked on top of #[0-9]+, please merge that one first$/.test(body);

            const stackedBodyFor = (prNumber) =>
              `This PR is stacked on top of #${prNumber}, please merge that one first`;

            const listReviews = async () =>
              github.paginate(github.rest.pulls.listReviews, {
                owner,
                repo,
                pull_number: prNumber,
                per_page: 100,
              });

            const findLatestBotReview = (reviews) => {
              const matches = reviews.filter(
                (review) =>
                  review.user &&
                  review.user.login === "github-actions[bot]" &&
                  review.state === "CHANGES_REQUESTED" &&
                  isStackedBody(review.body)
              );
              return matches.length > 0 ? matches[matches.length - 1] : null;
            };

            const dismissReview = async (existingReview) => {
              if (!existingReview) {
                core.notice("Nothing to do: PR is not stacked");
                return;
              }
              await github.rest.pulls.dismissReview({
                owner,
                repo,
                pull_number: prNumber,
                review_id: existingReview.id,
                message: "PR is now based on main; unblocking",
              });
              await github.rest.pulls.updateReview({
                owner,
                repo,
                pull_number: prNumber,
                review_id: existingReview.id,
                body: "",
              });
              core.notice("Dismissed review");
            };

            const reviews = await listReviews();
            const existingReview = findLatestBotReview(reviews);

            if (isMain) {
              await dismissReview(existingReview);
              return;
            }

            const pulls = await github.paginate(github.rest.pulls.list, {
              owner,
              repo,
              state: "open",
              per_page: 100,
            });

            const stackedOn = pulls.find(
              (pr) => pr.number !== prNumber && pr.head && pr.head.ref === baseRef
            );

            if (!stackedOn) {
              await dismissReview(existingReview);
              return;
            }

            const body = stackedBodyFor(stackedOn.number);

            if (!existingReview) {
              await github.rest.pulls.createReview({
                owner,
                repo,
                pull_number: prNumber,
                event: "REQUEST_CHANGES",
                body: body,
              });
              core.notice("Created review");
              return;
            }

            if (existingReview.body !== body) {
              await github.rest.pulls.updateReview({
                owner,
                repo,
                pull_number: prNumber,
                review_id: existingReview.id,
                body: body,
              });
              core.notice("Updated review body");
              return;
            }

            core.notice("PR is stacked");
